package main

import (
	"strings"
	"testing"
)

func TestInterpretString(t *testing.T) {
	tests := [][2]interface{}{
		{"", 0},
		{"()", 1},
		{"(())", 2},
		{"((()))", 3},
		{"(((())))", 4},
		{"(())()", 1},
		{"((()))()", 2},
		{"(((())))()", 3},
		{"((((()))))()", 4},
		{"((()))()()", 1},
		{"(((())))()()", 2},
		{"((((()))))()()", 3},

		{"()()", 0},
		{"()(())", 0},
		{"(())(())", 1},
		{"(())((()))", 1},

		{"()()()", -1},
		{"()()(())", -1},
		{"()()((()))", -1},
		{"()(())()", -1},
		{"()(())(())", -1},

		{"()()()()", 1},
		{"()()()()()", 0},
		{"(()()()())", 2},

		{"(()())", 1},
		{"((()()))", 2},
		{"((())())", 2},
		{"((()))()", 2},

		{"()()()(())()", 1},
		{"()()()((()))()", 2},
		{"()()()(((())))()", 3},
		{"()()()(())(())", 1},
		{"()()()((()))(())", 2},
		{"()()()(((())))(())", 3},
		{"()()()(())((()))", 1},
		{"()()()((()))((()))", 2},
		{"()()()(((())))((()))", 3},
	}
	for _, pair := range tests {
		p, r := []byte(pair[0].(string)), pair[1].(int)
		parsed := Parse(p)
		c := Count(parsed)
		if r != c {
			t.Errorf("Failure: got %d wanted %d in %s", c, r, p)
		} else {
			t.Logf("Success: got %d wanted %d in %s", c, r, p)
		}
	}
}

func TestParameters(t *testing.T) {
	tests := [][2]interface{}{
		{"()()(())(()())()", 0},
		{"()()(())(()())(())", 1},
		{"()()(())(()())((()))", 2},
		{"()()(())(()())(((())))", 3},

		{"()()()(())()()", 0},
		{"()()()(())(())()", 0},
		{"()()()(())((()))()", 0},

		{"()()(())(())()()", 0},
		{"()()(())(())(())()", 0},
		{"()()(())(())((()))()", 0},

		{"()()(()())(()()())()", 0},
		{"()()(()())(()()())(())", 1},
		{"()()(()())(()()())((()))", 2},
		{"()()(()())(()()())(((())))", 3},

		{"()()()(()()())()", -1},
		{"()()()(()()())(())", -1},
		{"()()()(()()())((()))", -1},
		{"()()()(()()())(((())))", -1},

		{"()()()( ()()((*))((*)()) ()     )", 1},
		{"()()()( ()()((*))((*)()) (())   )", 2},
		{"()()()( ()()((*))((*)()) ((())) )", 3},

		{"()()()( ()()((*))((*)()) ()     )()", 0},
		{"()()()( ()()((*))((*)()) (())   )()", 1},
		{"()()()( ()()((*))((*)()) ((())) )()", 2},

		//Call method in the global scope
		{"()()()( ()()((*))((*)()) )()()", 0},
		{"()()()( ()()((*))((*)()) )()(())", 1},
		{"()()()( ()()((*))((*)()) )()((()))", 2},

		//Call method in the global scope without overwriting
		{"()()(())( ()()()(()()) )()()", 0},
		{"()()(())( ()()()(()()) )()(())", 0},
		{"()()(())( ()()()(()()) )()((()))", 0},

		//Call method in the global scope with overwriting zero
		{"()()(*)(  ()()((*))((*)()) (*()) )()", 0},
		{"()()(*)(  ()()((*))((*)()) (*()) )(())", 1},
		{"()()(*)(  ()()((*))((*)()) (*()) )((()))", 2},

		//Calls method given as argument that calls method defined in the
		// scope that calls the method, which is a submethod of the method
		// that holds said argument
		{"()()(*)(  ()()((*))(*()()) ()     )( ()()()( (*)() ) )", 0},
		{"()()(*)(  ()()((*))(*()()) (())   )( ()()()( (*)() ) )", 1},
		{"()()(*)(  ()()((*))(*()()) ((())) )( ()()()( (*)() ) )", 2},

		{"()()(*)(  ()()((*))( ()()((*)())( *() )()  )(*)     )((()))", 0},
		{"()()(*)(  ()()((*))( ()()((*)())( *() )()  )((*))   )((()))", 2},
		{"()()(*)(  ()()((*))( ()()((*)())( *() )()  )(((*))) )((()))", 2},

		//Calling method with argument from user
		{`
		()()( * )(
			()()( (()) )(
				(())()(*())
			)(
				()()( (*) )(
					(*)()
				)
			)
		)()`, 0}, {`
		()()( * )(
			()()( (()) )(
				(())()(*())
			)(
				()()( (*) )(
					(*)()
				)
			)
		)(())`, 1}, {`
		()()( * )(
			()()( (()) )(
				(())()(*())
			)(
				()()( (*) )(
					(*)()
				)
			)
		)((()))`, 2},

		//Calling method gotten from argument
		{`
		()()( (()) )(
			(())()( (()) )
		)(
			()()( (*) )(
				()()( (*)() )(
					(*)()()
				)()
			)
		)
		`, 0}, {`
		()()( (()) )(
			(())()( ((())) )
		)(
			()()( (*) )(
				()()( (*)() )(
					(*)()()
				)()
			)
		)
		`, 0}, {`
		()()( (()) )(
			(())()( (((()))) )
		)(
			()()( (*) )(
				()()( (*)() )(
					(*)()()
				)()
			)
		)
		`, 0},

		//Calling method that may get overwritten
		{`
		()()( (()) )(
			(())()( (()) )
		)(
			()()( (*) )(
				()()( (*)() )(
					(())()
				)()
			)
		)
		`, 0}, {`
		()()( (()) )(
			(())()( (()) )
		)(
			()()( (*) )(
				()()( (*)() )(
					(())()
				)(())
			)
		)
		`, 1}, {`
		()()( (()) )(
			(())()( ((())) )
		)(
			()()( (*) )(
				()()( (*)() )(
					(())()
				)((((()))))
			)
		)
		`, 2}, {`
		()()( (()) )(
			(())()( ((())) )
		)(
			()()( (*) )(
				()()( (*)() )(
					(())()((()))
				)((((()))))
			)
		)
		`, 3},

		//Calling recursive until overwritten
		{`
		()()( (()) )(
			(())()( (()) )
		)(
			()()( (*) )(
				()()( (*)() )(
					(())()( (*)() )
				)(())
			)
		)
		`, 0}, /* {`
		()()( (()) )(
			(())()( ((())) )
		)(
			()()( (*) )(
				()()( (*)() )(
					(())()( (*)() )
				)()
			)
		)
		`, -1}, {`
		()()( (()) )(
			(())()( (((()))) )
		)(
			()()( (*) )(
				()()( (*)() )(
					(())()( (*)() )
				)()
			)
		)
		`, -1},*/

		/*{`
		()()( (()) )(
			(())()( (()) )
		)(
			()()( (*) )(
				()()( (*)() )(
					((  (())()( (*)() )  ))
				)()
			)
		)
		`, -1}, {`
		()()( (()) )(
			(())()( ((())) )
		)(
			()()( (*) )(
				()()( (*)() )(
					((  (())()( (*)() )  ))
				)()
			)
		)
		`, 2}, {`
		()()( (()) )(
			(())()( ((((())))) )
		)(
			()()( (*) )(
				()()( (*)() )(
					((  (())()( (*)() )  ))
				)()
			)
		)
		`, 4},*/
	}
	for _, pair := range tests {
		s := pair[0].(string)
		originalString := s
		s = strings.Replace(s, "*", "((((()))))", -1)
		s = strings.Replace(s, " ", "", -1)
		s = strings.Replace(s, "\t", "", -1)
		s = strings.Replace(s, "\n", "", -1)

		p, r := []byte(s), pair[1].(int)
		c := Count(Parse(p))
		if r != c {
			t.Errorf("Failure: got %d wanted %d in %s", c, r, originalString)
		} else {
			t.Logf("Success: got %d wanted %d in %s", c, r, originalString)
		}
	}
}
